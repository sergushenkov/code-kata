### Предварительная оценка задачи:
этап | плановое время | фактическое время |
---|---|---|
планирование   | 15' | 16'
проектирование | 10' | 5'
кодирование    | 90' | 143'
тестирование   | 10' | 5'
рефлексия      | 20' | 40'

### Фактические затраты времени (детально):
этап | начало работы | грязное время | чистое время | время прерываний | комментарий |
---|---|---|---|---|---|
планирование | 21-20 | 11 | 11 | 0 | сбор требований  
планирование | 21-32 |  5 |  5 | 0 | собственно планирование
проектирование | 21-37 | 5 | 5 | 0 | мало, даже с учетом того что перешёл с процедурного стиля на ООП
кодирование  | 10-20 | 40 | 40 | 0 | разбирался с работой pytest
кодирование  | 10-30 | 10 | 10 | 0 | set_starting_position() - забыл .strip()
кодирование  | 12-24 | 24 | 24 | 0 | show_generation()
кодирование  | 12-50 | 27 | 27 | 0 | check_neighbor()
кодирование  | 13-26 | 27 | 27 | 0 | отладка check_neighbor() - ошибся в тестах + next_generation()
кодирование  | 14-05 | 15 | 15 | 0 | main()
тестирование | 14-25 |  5 | 5  | 0 | ручное тестирование
рефлексия    | 14-30 | 40 | 40 | 0 | набор текста

### Ошибки
* input() вместо fd.readline() (код 50)
* забыл strip('\n') (код 50)
* ООП лучше чем процедурный (код 10)
* лишние пустые строки в шаблоне вывода (код 70)
* ошибка в тесте (код 70)
* настройка pytest (код 100)

#### input() вместо fd.readline() + забыл strip('\n')
Давно не использовал парсинг из файла через readline() - обычно либо input() использую, либо читаю файл целиком и обрабатываю все строки по единому алгоритму. Просто автоматизм
#### ООП лучше чем процедурный
Написав первую функцию сообразил, что с ООП будет проще, не надо будет передавать кучу параметров - переделал
#### лишние пустые строки в шаблоне вывода
Практически не тестировал вывод на экран через pytest - поэтому когда кодировал проглядел, что разное количество пустых строк
#### ошибка в тесте
Вот за это больше всего обидно - после первой ошибки исправил код программы, но не поправил тест. Дальше ошибся - какой из тестов упал и долго искал ошибку там где её нет
#### настройка pytest
Давно не использовал плюс решал на рабочем компе, где стоит venv - сразу запустить не удалось, пришлось подумать

### Рефлексия
#### ожидаемое и реальное количество ошибок на каждом шаге
* на планировании - ошибка по распределению времени заметная, но не знаю надо ли это учитывать
* на проектировании - ожидал 0, получил 1
* на кодирование ожидаемое заранее не продумывал, но 2 ошибки на страницу кода (30-35 строк) кажется приемлемым, получилось даже меньше - 1 ошибка на страницу в среднем
* на тестировании сложно отдельно учесть - программирую почти в парадигме TDD, так что они размазаны по кодированию
#### время, потраченное на устранение ошибок на каждом шаге
* ошибка проектирования обошлась в 5 минут - потому что рано выявилась
* ошибки кодирования - 2 минуты - с TDD сразу выявляются
* единственная ошибка - минут на 15 - ошибка в тесте, когда искал ошибку, которой не было
#### среднее время удаления ошибок на каждом шаге
5 минут
#### какие типы ошибок встречаются чаще всего
Тут слишком маленькая статистика - но получается 
* 50 - ошибки программного интерфейса
* 70 - ошибки данных 
#### какие типы ошибок дольше всего удалять
100 - ошибки окружения - потому что всерьёз изучать ленюсь, только то что нужно в конкретной ситуации (и это быстро забывается)
#### распределелние ошибок по типам дефектов
* 10 - 1
* 50 - 2
* 70 - 2
* 100 - 1
#### распределелние времени исправления ошибок по типам дефектов
* 10 - 5
* 50 - 2
* 70 - 8
* 100 - 15
#### количество ошибок в час
Проектирование, кодирование, тестирование - 153 минуты - 2.5 часа, 6 ошибок
Грубо - чуть больше двух ошибок в час
